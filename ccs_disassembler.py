###############################
# CCS Disassembler
# For Raytheon Research Project
# Dr. Clem Izurieta
# Dr. Brock LaMeres
# Written by Walker Ward
###############################
import logging
import os
import subprocess
from logging import Logger

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
logger: Logger = logging.getLogger(__name__)


def inject_malware_into_binary() -> None:
    # TODO: Malware class that abstractly implements different types of malware by overriding inject()
    pass


def check_malware(binary_file_directory: str, binary_file_name: str) -> float:
    # subprocess.call(['java', '-jar', 'jarname.jar', arg_variable1, arg_variableN]) - datasciencelearner.com
    pique_bin_jar_file_name: str = "msusel-pique-bin-0.0.1"
    pique_bin_properties_file_name: str = "pique-bin.properties"
    pique_bin_jar_file_directory: str = f"{os.getcwd()}\PIQUE-Bin-Jar\\"
    with open(f"{pique_bin_jar_file_directory}{pique_bin_properties_file_name}", "r") as pique_bin_properties:
        replacement_pique_bin_file_text: str = ""
        for line in pique_bin_properties:
            if "project.root=" in line:
                # line = f"project.root=./{binary_file_directory}\\{binary_file_name}\n"
                # line = f"project.root=./{binary_file_name}\n"
                # line = "project.root=./busybox-1.30.1_lite_busybox_unstripped_x86_64"
                pass
            replacement_pique_bin_file_text = replacement_pique_bin_file_text + line
        pique_bin_properties.close()
        with open(f"{pique_bin_jar_file_directory}{pique_bin_properties_file_name}", "w") as pique_bin_properties_replacement:
            pique_bin_properties_replacement.write(replacement_pique_bin_file_text)
            pique_bin_properties_replacement.close()
    os.chdir(pique_bin_jar_file_directory)
    print(os.getcwd())
    return subprocess.call(['java', '-jar', f"{pique_bin_jar_file_name}.jar"])
    #return subprocess.call(['java', '-cp', f"{pique_bin_jar_file_directory}{pique_bin_jar_file_name}.jar"])
    pass


def main() -> None:
    """
    Generates assembly for a binary generated by the MSP430 in CCS.
    - Checks that the input file exists.
    - Checks if the output file already exists. If so removes it.
    - Runs dis430.exe on the input file and output file.
    - Checks the exit status of the dis430.exe.
    - Note: Extremely dependant on package structure.
    :raise: OSError if the input file does not exists.
    :raise: OSError if the disassembler failed.
    """
    disassembler_directory: str = r'C:\ti\ccs1040\ccs\tools\compiler\ti-cgt-msp430_20.2.5.LTS\bin'
    disassembler_executable: str = r'dis430.exe'
    disassembler_input_file_name: str = "Motor_mover_C.out"
    disassembler_input_file_directory: str = rf"{os.getcwd()}\ccs_workspace\{disassembler_input_file_name.replace('.out', '')}\Debug"
    disassembler_output_file_name: str = "generated_disassembly.txt"
    disassembler_output_file_directory: str = rf"{os.getcwd()}\generated_disassembly"

    # Check if the disassembler input exists.
    if not os.path.exists(rf"{disassembler_input_file_directory}\{disassembler_input_file_name}"):
        raise OSError(rf"{disassembler_input_file_directory}\{disassembler_input_file_name} does not exist")

    # Run PIQUE-bin.
    pique_result: float = check_malware(disassembler_input_file_directory, disassembler_input_file_name)
    logger.info(pique_result)

    # Check if the output file already exists. If it exists delete in.
    if os.path.exists(rf"{disassembler_output_file_directory}\{disassembler_output_file_name}"):
        os.remove(rf"{disassembler_output_file_directory}\{disassembler_output_file_name}")
        logger.info(rf"Removed {disassembler_output_file_directory}\{disassembler_output_file_name}")

    # Call the disassembler.
    disassembler_exit_status: int = os.system(
        rf"{disassembler_directory}\{disassembler_executable} {disassembler_input_file_directory}\{disassembler_input_file_name} {disassembler_output_file_directory}\{disassembler_output_file_name}")
    logger.debug(f"Disassembler exist status: {disassembler_exit_status}")
    if disassembler_exit_status != 0:
        raise OSError(
            f"Disassembler failed to generate disassembly for {disassembler_input_file_name} with exit status {disassembler_exit_status}")
    else:
        logger.info(f'Generated {disassembler_output_file_name} at the directory {disassembler_output_file_directory}')


if __name__ == '__main__':
    main()
