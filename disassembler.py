"""
# CCS Disassembler
# For Raytheon Research Project and Interdisciplinary Capstone Project
# Dr. Clem Izurieta
# Dr. Brock LaMeres
# Written by Walker Ward and Michael Heidal
"""
import os
import pathlib
import subprocess

from ccs_project import CCSProject
from pique_bin import PiqueBin
from static_utilities import StaticUtilities


class Disassembler:
    """
    Disassembles an MSP430 binary.
    """

    def __init__(self, ccs_project_to_disassemble: CCSProject, *, disassembler_output_file_name: str = "generated_disassembly.txt") -> None:
        self.ccs_project: CCSProject = ccs_project_to_disassemble
        self.disassembler_directory: pathlib.Path = StaticUtilities.project_root_directory() / 'tools'
        self.disassembler_executable: str = 'dis430.exe'
        self.disassembler_output_file_name: str = disassembler_output_file_name
        self.disassembler_output_file_directory: pathlib.Path = pathlib.Path(rf"{StaticUtilities.project_root_directory()}\generated_disassembly")
        self.disassembler_exit_status: int = 0
        StaticUtilities.logger.debug(f"{Disassembler.__name__} object initialized")

    def disassemble(self) -> None:
        """
        Generates disassembly for a binary generated by the MSP430 in CCS.
        - Checks that the input file exists.
        - Checks if the output file already exists. If so removes it.
        - Runs dis430.exe on the input file and output file.
        - Checks the exit status of the dis430.exe.
        - Note: Extremely dependent on package structure.
        :raise: OSError if the input file does not exist.
        :raise: OSError if the disassembler failed.
        """

        # Check if the disassembler input exists.
        StaticUtilities.file_should_exist(self.ccs_project.path, self.ccs_project.source_file)

        # Check if the output file already exists. If it exists delete in.
        if os.path.exists(self.disassembler_output_file_directory / self.disassembler_output_file_name):
            os.remove(rf"{self.disassembler_output_file_directory}\{self.disassembler_output_file_name}")
            StaticUtilities.logger.info(
                rf"Removed {self.disassembler_output_file_directory}\{self.disassembler_output_file_name}")

        self.disassembler_exit_status = subprocess.run(
            rf"{self.disassembler_directory}\{self.disassembler_executable} {self.ccs_project.path}\{self.ccs_project.binary_file_path} {self.disassembler_output_file_directory}\{self.disassembler_output_file_name}",
            stdout=subprocess.DEVNULL,
            stderr=subprocess.STDOUT)
        StaticUtilities.logger.debug(f"Disassembler exit status: {self.disassembler_exit_status.returncode}")
        if self.disassembler_exit_status.returncode != 0:
            raise OSError(
                f"Disassembler failed to generate disassembly for {self.ccs_project.binary_file_path} with exit status {self.disassembler_exit_status}")
        else:
            StaticUtilities.logger.info(
                f'Disassembler generated {self.disassembler_output_file_name} at the directory {self.disassembler_output_file_directory}')
            self.ccs_project.set_disassembly_file_path(pathlib.Path(rf"{self.disassembler_output_file_directory}\{self.disassembler_output_file_name}"))


if __name__ == '__main__':
    ccs_project: CCSProject = CCSProject(project_name="test_target", source_file="main.c", path=pathlib.Path(rf"{StaticUtilities.project_root_directory()}\ccs_workspace\test_target"))
    disassembler: Disassembler = Disassembler(ccs_project_to_disassemble=ccs_project)
    disassembler.disassemble()
